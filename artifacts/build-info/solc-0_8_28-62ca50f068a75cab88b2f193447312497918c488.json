{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-62ca50f068a75cab88b2f193447312497918c488",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/NFTMarketplace.sol": "project/contracts/NFTMarketplace.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.4.0/access/Ownable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC2981.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC2981.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Interface for the NFT Royalty Standard.\n *\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\n */\ninterface IERC2981 is IERC165 {\n    /**\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\n     *\n     * NOTE: ERC-2981 allows setting the royalty to 100% of the price. In that case all the price would be sent to the\n     * royalty receiver and 0 tokens to the seller. Contracts dealing with royalty should consider empty transfers.\n     */\n    function royaltyInfo(\n        uint256 tokenId,\n        uint256 salePrice\n    ) external view returns (address receiver, uint256 royaltyAmount);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/common/ERC2981.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/common/ERC2981.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC2981} from \"../../interfaces/IERC2981.sol\";\nimport {IERC165, ERC165} from \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of the NFT Royalty Standard, a standardized way to retrieve royalty payment information.\n *\n * Royalty information can be specified globally for all token ids via {_setDefaultRoyalty}, and/or individually for\n * specific token ids via {_setTokenRoyalty}. The latter takes precedence over the first.\n *\n * Royalty is specified as a fraction of sale price. {_feeDenominator} is overridable but defaults to 10000, meaning the\n * fee is specified in basis points by default.\n *\n * IMPORTANT: ERC-2981 only specifies a way to signal royalty information and does not enforce its payment. See\n * https://eips.ethereum.org/EIPS/eip-2981#optional-royalty-payments[Rationale] in the ERC. Marketplaces are expected to\n * voluntarily pay royalties together with sales, but note that this standard is not yet widely supported.\n */\nabstract contract ERC2981 is IERC2981, ERC165 {\n    struct RoyaltyInfo {\n        address receiver;\n        uint96 royaltyFraction;\n    }\n\n    RoyaltyInfo private _defaultRoyaltyInfo;\n    mapping(uint256 tokenId => RoyaltyInfo) private _tokenRoyaltyInfo;\n\n    /**\n     * @dev The default royalty set is invalid (eg. (numerator / denominator) >= 1).\n     */\n    error ERC2981InvalidDefaultRoyalty(uint256 numerator, uint256 denominator);\n\n    /**\n     * @dev The default royalty receiver is invalid.\n     */\n    error ERC2981InvalidDefaultRoyaltyReceiver(address receiver);\n\n    /**\n     * @dev The royalty set for a specific `tokenId` is invalid (eg. (numerator / denominator) >= 1).\n     */\n    error ERC2981InvalidTokenRoyalty(uint256 tokenId, uint256 numerator, uint256 denominator);\n\n    /**\n     * @dev The royalty receiver for `tokenId` is invalid.\n     */\n    error ERC2981InvalidTokenRoyaltyReceiver(uint256 tokenId, address receiver);\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165) returns (bool) {\n        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /// @inheritdoc IERC2981\n    function royaltyInfo(\n        uint256 tokenId,\n        uint256 salePrice\n    ) public view virtual returns (address receiver, uint256 amount) {\n        RoyaltyInfo storage _royaltyInfo = _tokenRoyaltyInfo[tokenId];\n        address royaltyReceiver = _royaltyInfo.receiver;\n        uint96 royaltyFraction = _royaltyInfo.royaltyFraction;\n\n        if (royaltyReceiver == address(0)) {\n            royaltyReceiver = _defaultRoyaltyInfo.receiver;\n            royaltyFraction = _defaultRoyaltyInfo.royaltyFraction;\n        }\n\n        uint256 royaltyAmount = (salePrice * royaltyFraction) / _feeDenominator();\n\n        return (royaltyReceiver, royaltyAmount);\n    }\n\n    /**\n     * @dev The denominator with which to interpret the fee set in {_setTokenRoyalty} and {_setDefaultRoyalty} as a\n     * fraction of the sale price. Defaults to 10000 so fees are expressed in basis points, but may be customized by an\n     * override.\n     */\n    function _feeDenominator() internal pure virtual returns (uint96) {\n        return 10000;\n    }\n\n    /**\n     * @dev Sets the royalty information that all ids in this contract will default to.\n     *\n     * Requirements:\n     *\n     * - `receiver` cannot be the zero address.\n     * - `feeNumerator` cannot be greater than the fee denominator.\n     */\n    function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {\n        uint256 denominator = _feeDenominator();\n        if (feeNumerator > denominator) {\n            // Royalty fee will exceed the sale price\n            revert ERC2981InvalidDefaultRoyalty(feeNumerator, denominator);\n        }\n        if (receiver == address(0)) {\n            revert ERC2981InvalidDefaultRoyaltyReceiver(address(0));\n        }\n\n        _defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);\n    }\n\n    /**\n     * @dev Removes default royalty information.\n     */\n    function _deleteDefaultRoyalty() internal virtual {\n        delete _defaultRoyaltyInfo;\n    }\n\n    /**\n     * @dev Sets the royalty information for a specific token id, overriding the global default.\n     *\n     * Requirements:\n     *\n     * - `receiver` cannot be the zero address.\n     * - `feeNumerator` cannot be greater than the fee denominator.\n     */\n    function _setTokenRoyalty(uint256 tokenId, address receiver, uint96 feeNumerator) internal virtual {\n        uint256 denominator = _feeDenominator();\n        if (feeNumerator > denominator) {\n            // Royalty fee will exceed the sale price\n            revert ERC2981InvalidTokenRoyalty(tokenId, feeNumerator, denominator);\n        }\n        if (receiver == address(0)) {\n            revert ERC2981InvalidTokenRoyaltyReceiver(tokenId, address(0));\n        }\n\n        _tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);\n    }\n\n    /**\n     * @dev Resets royalty information for the token id back to the global default.\n     */\n    function _resetTokenRoyalty(uint256 tokenId) internal virtual {\n        delete _tokenRoyaltyInfo[tokenId];\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC721/IERC721.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC721/IERC721.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC-721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC-721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC-721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Context.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/introspection/ERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/introspection/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/ReentrancyGuard.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
      },
      "project/contracts/NFTMarketplace.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/common/ERC2981.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/**\n * @title NFTMarketplace\n * @notice Decentralized marketplace for buying and selling Song NFTs\n * @dev Supports ERC2981 royalties and platform fees\n */\ncontract NFTMarketplace is Ownable, ReentrancyGuard {\n    \n    // ============ STRUCTS ============\n    \n    struct Listing {\n        address seller;\n        uint256 price;\n        uint256 listedAt;\n    }\n\n    struct Offer {\n        address buyer;\n        uint256 amount;\n        uint256 expiry;\n    }\n\n    // ============ STATE VARIABLES ============\n    \n    // Platform fee in basis points (250 = 2.5%)\n    uint256 public platformFeeBps = 250;\n    \n    // Maximum platform fee (10%)\n    uint256 public constant MAX_PLATFORM_FEE = 1000;\n    \n    // Fee recipient address\n    address public feeRecipient;\n    \n    // Minimum listing price\n    uint256 public minListingPrice = 0.001 ether;\n    \n    // nft address => tokenId => Listing\n    mapping(address => mapping(uint256 => Listing)) public listings;\n    \n    // nft address => tokenId => Offer[]\n    mapping(address => mapping(uint256 => Offer[])) public offers;\n    \n    // Total volume traded\n    uint256 public totalVolume;\n    \n    // Total fees collected\n    uint256 public totalFeesCollected;\n\n    // ============ EVENTS ============\n\n    event Listed(\n        address indexed seller,\n        address indexed nft,\n        uint256 indexed tokenId,\n        uint256 price,\n        uint256 timestamp\n    );\n\n    event Sold(\n        address indexed buyer,\n        address indexed seller,\n        address indexed nft,\n        uint256 tokenId,\n        uint256 price,\n        uint256 platformFee,\n        uint256 royaltyAmount\n    );\n\n    event Cancelled(\n        address indexed seller,\n        address indexed nft,\n        uint256 indexed tokenId\n    );\n\n    event PriceUpdated(\n        address indexed seller,\n        address indexed nft,\n        uint256 indexed tokenId,\n        uint256 oldPrice,\n        uint256 newPrice\n    );\n\n    event OfferMade(\n        address indexed buyer,\n        address indexed nft,\n        uint256 indexed tokenId,\n        uint256 amount,\n        uint256 expiry\n    );\n\n    event OfferAccepted(\n        address indexed seller,\n        address indexed buyer,\n        address indexed nft,\n        uint256 tokenId,\n        uint256 amount\n    );\n\n    event OfferCancelled(\n        address indexed buyer,\n        address indexed nft,\n        uint256 indexed tokenId,\n        uint256 offerIndex\n    );\n\n    event PlatformFeeUpdated(uint256 oldFee, uint256 newFee);\n    event FeeRecipientUpdated(address oldRecipient, address newRecipient);\n    event MinListingPriceUpdated(uint256 oldPrice, uint256 newPrice);\n\n    // ============ CONSTRUCTOR ============\n\n    constructor(address _feeRecipient) Ownable(msg.sender) {\n        require(_feeRecipient != address(0), \"Invalid fee recipient\");\n        feeRecipient = _feeRecipient;\n    }\n\n    // ============ LISTING FUNCTIONS ============\n\n    /**\n     * @notice List an NFT for sale\n     * @param nft NFT contract address\n     * @param tokenId Token ID to list\n     * @param price Listing price in wei\n     */\n    function listNFT(\n        address nft,\n        uint256 tokenId,\n        uint256 price\n    ) external nonReentrant {\n        require(price >= minListingPrice, \"Price below minimum\");\n        require(listings[nft][tokenId].price == 0, \"Already listed\");\n\n        IERC721 token = IERC721(nft);\n\n        require(token.ownerOf(tokenId) == msg.sender, \"Not owner\");\n        require(\n            token.getApproved(tokenId) == address(this) ||\n            token.isApprovedForAll(msg.sender, address(this)),\n            \"Marketplace not approved\"\n        );\n\n        listings[nft][tokenId] = Listing({\n            seller: msg.sender,\n            price: price,\n            listedAt: block.timestamp\n        });\n\n        emit Listed(msg.sender, nft, tokenId, price, block.timestamp);\n    }\n\n    /**\n     * @notice Update listing price\n     * @param nft NFT contract address\n     * @param tokenId Token ID\n     * @param newPrice New price in wei\n     */\n    function updatePrice(\n        address nft,\n        uint256 tokenId,\n        uint256 newPrice\n    ) external nonReentrant {\n        Listing storage listing = listings[nft][tokenId];\n        \n        require(listing.seller == msg.sender, \"Not seller\");\n        require(newPrice >= minListingPrice, \"Price below minimum\");\n        \n        uint256 oldPrice = listing.price;\n        listing.price = newPrice;\n        \n        emit PriceUpdated(msg.sender, nft, tokenId, oldPrice, newPrice);\n    }\n\n    /**\n     * @notice Buy a listed NFT\n     * @param nft NFT contract address\n     * @param tokenId Token ID to buy\n     */\n    function buyNFT(\n        address nft,\n        uint256 tokenId\n    ) external payable nonReentrant {\n        Listing memory listing = listings[nft][tokenId];\n\n        require(listing.price > 0, \"Not listed\");\n        require(msg.value == listing.price, \"Incorrect price\");\n        require(listing.seller != msg.sender, \"Cannot buy own listing\");\n\n        // Remove listing first (CEI pattern)\n        delete listings[nft][tokenId];\n\n        // Calculate fees\n        (uint256 platformFee, uint256 royaltyAmount, address royaltyReceiver) = \n            _calculateFees(nft, tokenId, listing.price);\n\n        uint256 sellerProceeds = listing.price - platformFee - royaltyAmount;\n\n        // Pay platform fee\n        if (platformFee > 0) {\n            (bool feeSuccess, ) = feeRecipient.call{value: platformFee}(\"\");\n            require(feeSuccess, \"Platform fee transfer failed\");\n        }\n\n        // Pay royalty\n        if (royaltyAmount > 0 && royaltyReceiver != address(0)) {\n            (bool royaltySuccess, ) = royaltyReceiver.call{value: royaltyAmount}(\"\");\n            require(royaltySuccess, \"Royalty transfer failed\");\n        }\n\n        // Pay seller\n        (bool sellerSuccess, ) = listing.seller.call{value: sellerProceeds}(\"\");\n        require(sellerSuccess, \"Seller transfer failed\");\n\n        // Transfer NFT\n        IERC721(nft).safeTransferFrom(listing.seller, msg.sender, tokenId);\n\n        // Update stats\n        totalVolume += listing.price;\n        totalFeesCollected += platformFee;\n\n        emit Sold(\n            msg.sender,\n            listing.seller,\n            nft,\n            tokenId,\n            listing.price,\n            platformFee,\n            royaltyAmount\n        );\n    }\n\n    /**\n     * @notice Cancel an active listing\n     * @param nft NFT contract address\n     * @param tokenId Token ID\n     */\n    function cancelListing(\n        address nft,\n        uint256 tokenId\n    ) external nonReentrant {\n        Listing memory listing = listings[nft][tokenId];\n\n        require(listing.seller == msg.sender, \"Not seller\");\n\n        delete listings[nft][tokenId];\n\n        emit Cancelled(msg.sender, nft, tokenId);\n    }\n\n    // ============ OFFER FUNCTIONS ============\n\n    /**\n     * @notice Make an offer on an NFT\n     * @param nft NFT contract address\n     * @param tokenId Token ID\n     * @param expiry Offer expiry timestamp\n     */\n    function makeOffer(\n        address nft,\n        uint256 tokenId,\n        uint256 expiry\n    ) external payable nonReentrant {\n        require(msg.value >= minListingPrice, \"Offer too low\");\n        require(expiry > block.timestamp, \"Invalid expiry\");\n        require(expiry <= block.timestamp + 30 days, \"Expiry too far\");\n\n        IERC721 token = IERC721(nft);\n        require(token.ownerOf(tokenId) != address(0), \"Token doesn't exist\");\n        require(token.ownerOf(tokenId) != msg.sender, \"Cannot offer on own NFT\");\n\n        offers[nft][tokenId].push(Offer({\n            buyer: msg.sender,\n            amount: msg.value,\n            expiry: expiry\n        }));\n\n        emit OfferMade(msg.sender, nft, tokenId, msg.value, expiry);\n    }\n\n    /**\n     * @notice Accept an offer\n     * @param nft NFT contract address\n     * @param tokenId Token ID\n     * @param offerIndex Index of offer to accept\n     */\n    function acceptOffer(\n        address nft,\n        uint256 tokenId,\n        uint256 offerIndex\n    ) external nonReentrant {\n        IERC721 token = IERC721(nft);\n        require(token.ownerOf(tokenId) == msg.sender, \"Not owner\");\n        \n        Offer[] storage tokenOffers = offers[nft][tokenId];\n        require(offerIndex < tokenOffers.length, \"Invalid offer index\");\n        \n        Offer memory offer = tokenOffers[offerIndex];\n        require(offer.expiry > block.timestamp, \"Offer expired\");\n        require(offer.amount > 0, \"Offer cancelled\");\n\n        // Remove offer\n        tokenOffers[offerIndex].amount = 0;\n\n        // Remove listing if exists\n        if (listings[nft][tokenId].price > 0) {\n            delete listings[nft][tokenId];\n        }\n\n        // Calculate fees\n        (uint256 platformFee, uint256 royaltyAmount, address royaltyReceiver) = \n            _calculateFees(nft, tokenId, offer.amount);\n\n        uint256 sellerProceeds = offer.amount - platformFee - royaltyAmount;\n\n        // Pay platform fee\n        if (platformFee > 0) {\n            (bool feeSuccess, ) = feeRecipient.call{value: platformFee}(\"\");\n            require(feeSuccess, \"Platform fee transfer failed\");\n        }\n\n        // Pay royalty\n        if (royaltyAmount > 0 && royaltyReceiver != address(0)) {\n            (bool royaltySuccess, ) = royaltyReceiver.call{value: royaltyAmount}(\"\");\n            require(royaltySuccess, \"Royalty transfer failed\");\n        }\n\n        // Pay seller\n        (bool sellerSuccess, ) = msg.sender.call{value: sellerProceeds}(\"\");\n        require(sellerSuccess, \"Seller transfer failed\");\n\n        // Transfer NFT\n        token.safeTransferFrom(msg.sender, offer.buyer, tokenId);\n\n        // Update stats\n        totalVolume += offer.amount;\n        totalFeesCollected += platformFee;\n\n        emit OfferAccepted(msg.sender, offer.buyer, nft, tokenId, offer.amount);\n    }\n\n    /**\n     * @notice Cancel an offer and get refund\n     * @param nft NFT contract address\n     * @param tokenId Token ID\n     * @param offerIndex Index of offer to cancel\n     */\n    function cancelOffer(\n        address nft,\n        uint256 tokenId,\n        uint256 offerIndex\n    ) external nonReentrant {\n        Offer[] storage tokenOffers = offers[nft][tokenId];\n        require(offerIndex < tokenOffers.length, \"Invalid offer index\");\n        \n        Offer memory offer = tokenOffers[offerIndex];\n        require(offer.buyer == msg.sender, \"Not offer maker\");\n        require(offer.amount > 0, \"Already cancelled\");\n\n        // Mark as cancelled\n        tokenOffers[offerIndex].amount = 0;\n\n        // Refund\n        (bool success, ) = msg.sender.call{value: offer.amount}(\"\");\n        require(success, \"Refund failed\");\n\n        emit OfferCancelled(msg.sender, nft, tokenId, offerIndex);\n    }\n\n    // ============ VIEW FUNCTIONS ============\n\n    /**\n     * @notice Get listing details\n     * @param nft NFT contract address\n     * @param tokenId Token ID\n     * @return seller Seller address\n     * @return price Listing price\n     * @return listedAt Listing timestamp\n     */\n    function getListing(address nft, uint256 tokenId) \n        external \n        view \n        returns (address seller, uint256 price, uint256 listedAt) \n    {\n        Listing memory listing = listings[nft][tokenId];\n        return (listing.seller, listing.price, listing.listedAt);\n    }\n\n    /**\n     * @notice Get all offers for a token\n     * @param nft NFT contract address\n     * @param tokenId Token ID\n     * @return Array of offers\n     */\n    function getOffers(address nft, uint256 tokenId) \n        external \n        view \n        returns (Offer[] memory) \n    {\n        return offers[nft][tokenId];\n    }\n\n    /**\n     * @notice Check if NFT is listed\n     * @param nft NFT contract address\n     * @param tokenId Token ID\n     * @return True if listed\n     */\n    function isListed(address nft, uint256 tokenId) external view returns (bool) {\n        return listings[nft][tokenId].price > 0;\n    }\n\n    /**\n     * @notice Calculate fees for a sale\n     * @param nft NFT contract address\n     * @param tokenId Token ID\n     * @param salePrice Sale price\n     * @return platformFee Platform fee amount\n     * @return royaltyAmount Royalty amount\n     * @return royaltyReceiver Royalty receiver address\n     */\n    function calculateFees(address nft, uint256 tokenId, uint256 salePrice)\n        external\n        view\n        returns (uint256 platformFee, uint256 royaltyAmount, address royaltyReceiver)\n    {\n        return _calculateFees(nft, tokenId, salePrice);\n    }\n\n    // ============ ADMIN FUNCTIONS ============\n\n    /**\n     * @notice Update platform fee\n     * @param newFeeBps New fee in basis points\n     */\n    function setPlatformFee(uint256 newFeeBps) external onlyOwner {\n        require(newFeeBps <= MAX_PLATFORM_FEE, \"Fee too high\");\n        \n        uint256 oldFee = platformFeeBps;\n        platformFeeBps = newFeeBps;\n        \n        emit PlatformFeeUpdated(oldFee, newFeeBps);\n    }\n\n    /**\n     * @notice Update fee recipient\n     * @param newRecipient New fee recipient address\n     */\n    function setFeeRecipient(address newRecipient) external onlyOwner {\n        require(newRecipient != address(0), \"Invalid address\");\n        \n        address oldRecipient = feeRecipient;\n        feeRecipient = newRecipient;\n        \n        emit FeeRecipientUpdated(oldRecipient, newRecipient);\n    }\n\n    /**\n     * @notice Update minimum listing price\n     * @param newMinPrice New minimum price\n     */\n    function setMinListingPrice(uint256 newMinPrice) external onlyOwner {\n        uint256 oldPrice = minListingPrice;\n        minListingPrice = newMinPrice;\n        \n        emit MinListingPriceUpdated(oldPrice, newMinPrice);\n    }\n\n    // ============ INTERNAL FUNCTIONS ============\n\n    /**\n     * @dev Calculate platform fee and royalty\n     */\n    function _calculateFees(address nft, uint256 tokenId, uint256 salePrice)\n        internal\n        view\n        returns (uint256 platformFee, uint256 royaltyAmount, address royaltyReceiver)\n    {\n        // Platform fee\n        platformFee = (salePrice * platformFeeBps) / 10000;\n\n        // Try to get royalty info (ERC2981)\n        try IERC2981(nft).royaltyInfo(tokenId, salePrice) returns (\n            address receiver,\n            uint256 amount\n        ) {\n            royaltyReceiver = receiver;\n            royaltyAmount = amount;\n        } catch {\n            // NFT doesn't support ERC2981\n            royaltyReceiver = address(0);\n            royaltyAmount = 0;\n        }\n\n        // Ensure fees don't exceed sale price\n        require(platformFee + royaltyAmount < salePrice, \"Fees exceed price\");\n    }\n}\n"
      }
    }
  }
}